{
    "NCC Python Function": {
        "prefix": "ncc-py-func",
        "body": [
            "def ${1:function_name}(${2:parameters}) -> ${3:ReturnType}:",
            "    \"\"\"",
            "    ${1:function_name} - ${4:Description}",
            "    ",
            "    Generated: January 30, 2026 | Authority: AZ PRIME Command",
            "    ",
            "    Args:",
            "        ${2:parameters}: ${5:Parameter description}",
            "    ",
            "    Returns:",
            "        ${3:ReturnType}: ${6:Return description}",
            "    \"\"\"",
            "    try:",
            "        logger.info(f\"[{${1:function_name}}] Starting execution\")",
            "        ",
            "        # Function logic here",
            "        result = {",
            "            'status': 'success',",
            "            'data': None,",
            "            'timestamp': datetime.now().isoformat()",
            "        }",
            "        ",
            "        logger.info(f\"[{${1:function_name}}] Completed successfully\")",
            "        return result",
            "    except Exception as e:",
            "        logger.error(f\"[{${1:function_name}}] Error: {e}\", exc_info=True)",
            "        raise"
        ],
        "description": "NCC Python function template with logging and error handling"
    },

    "NCC Data Analysis": {
        "prefix": "ncc-data-analysis",
        "body": [
            "def analyze_${1:data_type}(${2:data}) -> Dict[str, Any]:",
            "    \"\"\"",
            "    Analyze ${1:data_type} data and extract insights",
            "    ",
            "    Args:",
            "        ${2:data}: Input data for analysis",
            "    ",
            "    Returns:",
            "        Dict containing analysis results and insights",
            "    \"\"\"",
            "    try:",
            "        logger.info(f\"Starting ${1:data_type} analysis\")",
            "        ",
            "        # Data validation",
            "        if not ${2:data}:",
            "            raise ValueError(\"No ${1:data_type} data provided\")",
            "        ",
            "        # Analysis logic here",
            "        insights = []",
            "        metrics = {}",
            "        ",
            "        # Extract key insights",
            "        insights.append(f\"Found {len(${2:data})} ${1:data_type} records\")",
            "        ",
            "        # Calculate metrics",
            "        metrics['total_records'] = len(${2:data})",
            "        metrics['analysis_timestamp'] = datetime.now().isoformat()",
            "        ",
            "        result = {",
            "            'insights': insights,",
            "            'metrics': metrics,",
            "            'recommendations': [],",
            "            'status': 'completed'",
            "        }",
            "        ",
            "        logger.info(f\"${1:data_type} analysis completed successfully\")",
            "        return result",
            "    except Exception as e:",
            "        logger.error(f\"${1:data_type} analysis failed: {e}\", exc_info=True)",
            "        raise"
        ],
        "description": "NCC data analysis function template"
    },

    "NCC API Client": {
        "prefix": "ncc-api-client",
        "body": [
            "class NCC${1:Service}Client:",
            "    \"\"\"",
            "    Client for NCC ${1:Service} API interactions",
            "    \"\"\"",
            "    ",
            "    def __init__(self, base_url: str = \"${2:http://localhost:3000}\", timeout: int = 30):",
            "        self.base_url = base_url.rstrip('/')",
            "        self.timeout = timeout",
            "        self.session = requests.Session()",
            "        self.session.headers.update({",
            "            'User-Agent': 'NCC-${1:Service}Client/1.0',",
            "            'Content-Type': 'application/json'",
            "        })",
            "        logger.info(f\"NCC${1:Service}Client initialized with base URL: {base_url}\")",
            "    ",
            "    def ${3:method_name}(self, ${4:parameters}) -> Dict[str, Any]:",
            "        \"\"\"",
            "        ${3:method_name} - ${5:Description}",
            "        \"\"\"",
            "        try:",
            "            url = f\"{self.base_url}/${6:endpoint}\"",
            "            payload = ${4:parameters}",
            "            ",
            "            response = self.session.${7:post}(url, json=payload, timeout=self.timeout)",
            "            response.raise_for_status()",
            "            ",
            "            data = response.json()",
            "            logger.info(f\"${3:method_name} completed successfully\")",
            "            return data",
            "        except requests.exceptions.RequestException as e:",
            "            logger.error(f\"${3:method_name} failed: {e}\")",
            "            raise",
            "        except Exception as e:",
            "            logger.error(f\"Unexpected error in ${3:method_name}: {e}\", exc_info=True)",
            "            raise"
        ],
        "description": "NCC API client class template"
    },

    "NCC Logging Setup": {
        "prefix": "ncc-logging",
        "body": [
            "# NCC Logging Configuration",
            "import logging",
            "from logging.handlers import RotatingFileHandler",
            "import sys",
            "from pathlib import Path",
            "",
            "# Create logs directory if it doesn't exist",
            "logs_dir = Path(__file__).parent / 'logs'",
            "logs_dir.mkdir(exist_ok=True)",
            "",
            "# Configure logger",
            "logger = logging.getLogger('${1:module_name}')",
            "logger.setLevel(logging.${2:INFO})",
            "",
            "# Create formatters",
            "file_formatter = logging.Formatter(",
            "    '%(asctime)s | %(name)s | %(levelname)s | %(funcName)s:%(lineno)d | %(message)s'",
            ")",
            "console_formatter = logging.Formatter(",
            "    '%(levelname)s | %(name)s | %(message)s'",
            ")",
            "",
            "# File handler with rotation",
            "file_handler = RotatingFileHandler(",
            "    logs_dir / '${1:module_name}.log',",
            "    maxBytes=10*1024*1024,  # 10MB",
            "    backupCount=5",
            ")",
            "file_handler.setFormatter(file_formatter)",
            "file_handler.setLevel(logging.${2:INFO})",
            "",
            "# Console handler",
            "console_handler = logging.StreamHandler(sys.stdout)",
            "console_handler.setFormatter(console_formatter)",
            "console_handler.setLevel(logging.${3:WARNING})",
            "",
            "# Add handlers to logger",
            "logger.addHandler(file_handler)",
            "logger.addHandler(console_handler)",
            "",
            "# Prevent duplicate logs",
            "logger.propagate = False"
        ],
        "description": "NCC logging configuration template"
    },

    "NCC Performance Monitor": {
        "prefix": "ncc-performance",
        "body": [
            "import time",
            "from contextlib import contextmanager",
            "from typing import Any, Callable, Dict",
            "",
            "@contextmanager",
            "def ncc_performance_monitor(operation_name: str):",
            "    \"\"\"",
            "    Context manager to monitor performance of NCC operations",
            "    \"\"\"",
            "    start_time = time.perf_counter()",
            "    start_memory = ${1:get_memory_usage()}  # Implement based on your system",
            "    ",
            "    try:",
            "        logger.info(f\"Starting {operation_name}\")",
            "        yield",
            "    finally:",
            "        end_time = time.perf_counter()",
            "        end_memory = ${1:get_memory_usage()}",
            "        ",
            "        duration = end_time - start_time",
            "        memory_delta = end_memory - start_memory",
            "        ",
            "        logger.info(",
            "            f\"{operation_name} completed in {duration:.3f}s, \"",
            "            f\"memory delta: {memory_delta:+.2f}MB\"",
            "        )",
            "        ",
            "        # Log performance metrics",
            "        performance_metrics = {",
            "            'operation': operation_name,",
            "            'duration_seconds': duration,",
            "            'memory_delta_mb': memory_delta,",
            "            'timestamp': datetime.now().isoformat()",
            "        }",
            "        ${2:log_performance_metrics}(performance_metrics)",
            "",
            "def ${3:benchmark_function}(func: Callable, *args, iterations: int = 100, **kwargs) -> Dict[str, Any]:",
            "    \"\"\"",
            "    Benchmark a function's performance over multiple iterations",
            "    \"\"\"",
            "    times = []",
            "    ",
            "    for i in range(iterations):",
            "        start = time.perf_counter()",
            "        result = func(*args, **kwargs)",
            "        end = time.perf_counter()",
            "        times.append(end - start)",
            "    ",
            "    avg_time = sum(times) / len(times)",
            "    min_time = min(times)",
            "    max_time = max(times)",
            "    ",
            "    benchmark_result = {",
            "        'function': func.__name__,",
            "        'iterations': iterations,",
            "        'avg_time': avg_time,",
            "        'min_time': min_time,",
            "        'max_time': max_time,",
            "        'total_time': sum(times)",
            "    }",
            "    ",
            "    logger.info(f\"Benchmark completed: {benchmark_result}\")",
            "    return benchmark_result"
        ],
        "description": "NCC performance monitoring and benchmarking templates"
    },

    "NCC Configuration Manager": {
        "prefix": "ncc-config",
        "body": [
            "from typing import Any, Dict, Optional",
            "import json",
            "from pathlib import Path",
            "",
            "class NCCConfigurationManager:",
            "    \"\"\"",
            "    Centralized configuration management for NCC components",
            "    \"\"\"",
            "    ",
            "    def __init__(self, config_file: str = 'ncc_config.json'):",
            "        self.config_file = Path(__file__).parent / config_file",
            "        self._config: Dict[str, Any] = {}",
            "        self._load_config()",
            "    ",
            "    def _load_config(self) -> None:",
            "        \"\"\"Load configuration from file\"\"\"",
            "        try:",
            "            if self.config_file.exists():",
            "                with open(self.config_file, 'r') as f:",
            "                    self._config = json.load(f)",
            "                logger.info(f\"Configuration loaded from {self.config_file}\")",
            "            else:",
            "                logger.warning(f\"Configuration file {self.config_file} not found, using defaults\")",
            "                self._config = self._get_defaults()",
            "        except Exception as e:",
            "            logger.error(f\"Failed to load configuration: {e}\")",
            "            self._config = self._get_defaults()",
            "    ",
            "    def _get_defaults(self) -> Dict[str, Any]:",
            "        \"\"\"Get default configuration values\"\"\"",
            "        return {",
            "            'system': {",
            "                'name': 'NCC-Doctrine',",
            "                'version': '1.0.0',",
            "                'authority': 'AZ PRIME Command'",
            "            },",
            "            'performance': {",
            "                'max_memory_mb': 4096,",
            "                'timeout_seconds': 300,",
            "                'retry_attempts': 3",
            "            },",
            "            'logging': {",
            "                'level': 'INFO',",
            "                'max_file_size_mb': 10,",
            "                'backup_count': 5",
            "            }",
            "        }",
            "    ",
            "    def get(self, key: str, default: Any = None) -> Any:",
            "        \"\"\"Get configuration value by key\"\"\"",
            "        keys = key.split('.')",
            "        value = self._config",
            "        for k in keys:",
            "            if isinstance(value, dict) and k in value:",
            "                value = value[k]",
            "            else:",
            "                return default",
            "        return value",
            "    ",
            "    def set(self, key: str, value: Any) -> None:",
            "        \"\"\"Set configuration value\"\"\"",
            "        keys = key.split('.')",
            "        config = self._config",
            "        for k in keys[:-1]:",
            "            config = config.setdefault(k, {})",
            "        config[keys[-1]] = value",
            "        self._save_config()",
            "    ",
            "    def _save_config(self) -> None:",
            "        \"\"\"Save configuration to file\"\"\"",
            "        try:",
            "            with open(self.config_file, 'w') as f:",
            "                json.dump(self._config, f, indent=2)",
            "            logger.info(f\"Configuration saved to {self.config_file}\")",
            "        except Exception as e:",
            "            logger.error(f\"Failed to save configuration: {e}\")"
        ],
        "description": "NCC configuration management class template"
    }
}